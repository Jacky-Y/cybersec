1. rmi远程方法调用，是java远程方法调用的一个接口，客户端进行远程方法调用的前提有相应方法的接口，服务器有这个接口的实现，然后服务器使用接口实现类创建一个对象，并将这个对象绑定在rmi注册表，这样客户端就可以通过rmi协议+服务器ip+对象名去调用相应的远程方法，但实际上服务器并没有把远程方法返回，而是接收客户端的参数然后在自己这里执行这些方法，再把结果返回到客户端（此外rmi的通信端口一般是1099,而远程方法调用则会再随机分配一个端口）

2. JNDI，JNDI是命名和目录服务，可以通过对象名获得对象的引用，JNDI可以将rmi作为底层协议，进行远程方法调用，除了rmi之外，JNDI还可以把ldap等协议作为底层协议，向上提供统一的接口，更加方便。用JNDI的话，一般以Context作为入口，Context设置好环境，和远程服务提供者url，再通过bind和lookup函数绑定对象和查找对象
// 创建属性 Hashtable
Hashtable<String, String> env = new Hashtable<>();
env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
env.put(Context.PROVIDER_URL, "rmi://localhost:1099");
// 创建 JNDI 上下文
Context context = new InitialContext(env);

3. Reference，主要参考https://zhuanlan.zhihu.com/p/41806870?utm_id=0，https://www.cnblogs.com/nice0e3/p/13958047.html：
我们来到JNDI注入的核心部分，关于JNDI注入，@pwntester在BlackHat上的讲义中写的已经很详细。我们这里重点讲一下和RMI反序列化相关的部分。接触过JNDI注入的同学可能会疑问，不应该是RMI服务器最终执行远程方法么，为什么目标服务器lookup()一个恶意的RMI服务地址，会被执行恶意代码呢？


在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。


整个利用流程如下：

    目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；
    攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；
    攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；
    目标在进行lookup()操作时，会动态加载并实例化Factory类（首先会获取到Reference对象，获取到Reference对象后，会去寻找Reference中指定的Factory类，如果查找不到则会在Reference中指定的远程地址去进行请求这个Factory类），接着调用factory.getObjectInstance()获取外部远程对象实例；
    攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果；
    
    
4.抓包看到了poc的利用过程，首先初始化InitialContext，初始化的时候由于有服务器ip地址，会向服务器发包，然后bind的时候会向服务器发包，包含序列化的对象，然后lookup的时候也会向服务器发包，服务器执行完之后会向客户端返回查询结果。
